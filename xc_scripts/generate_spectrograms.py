#!/usr/bin/env python3
"""
Generate spectrogram images for clips produced by `process_species.py`.

The script scans the clip directory for a target species and writes one
spectrogram image per clip into `<root>/spectrograms/<species_slug>`.

Typical usage:
    python xc_scripts/generate_spectrograms.py --config xc_configs/config_cettia_cetti.yaml

The configuration file is shared with the rest of the pipeline. You can
override the clips or output directory via command-line arguments when
working with data on external drives.
"""

from __future__ import annotations

import argparse
from dataclasses import dataclass
from pathlib import Path
from typing import Iterable, Optional

import numpy as np
import yaml

import librosa
import librosa.display  # noqa: F401  # needed for specshow

import matplotlib

matplotlib.use("Agg")
import matplotlib.pyplot as plt  # noqa: E402

from tqdm import tqdm

# Supported audio extensions for clips generated by process_species.py
CLIP_EXTENSIONS = (".wav", ".flac", ".ogg", ".mp3", ".m4a")


def load_config(config_path: Optional[Path] = None) -> dict:
    """Load configuration file and back-fill defaults required by this script."""

    default_config: dict = {
        "species": {
            "scientific_name": "Sylvia atricapilla",
            "common_name": "Blackcap",
            "slug": "sylvia_atricapilla",
        },
        "paths": {
            "root": "/Volumes/Z Slim/zslim_birdcluster",
        },
        "spectrograms": {
            "sample_rate": None,  # Keep original sample rate
            "n_fft": 2048,
            "hop_length": 512,
            "n_mels": 128,
            "fmin": 0.0,
            "fmax": None,
            "top_db": 80.0,
            "cmap": "magma",
            "dpi": 150,
            "figsize": (6, 3),
            "image_format": "png",
            "base_url": None,
        },
    }

    if config_path:
        requested = config_path
        resolved = config_path if config_path.is_absolute() else Path.cwd() / config_path
        if not resolved.exists():
            raise SystemExit(
                f"Config file '{requested}' not found. Use '--config xc_configs/<name>.yaml'."
            )
        with resolved.open("r", encoding="utf-8") as handle:
            config = yaml.safe_load(handle) or {}
    else:
        config = {}

    # Merge defaults
    for section, defaults in default_config.items():
        if section not in config:
            config[section] = defaults
        elif isinstance(defaults, dict):
            for key, value in defaults.items():
                config[section].setdefault(key, value)

    return config


@dataclass
class SpectrogramSettings:
    """Convenience container for spectrogram parameters."""

    sample_rate: Optional[int]
    n_fft: int
    hop_length: int
    n_mels: int
    fmin: float
    fmax: Optional[float]
    top_db: float
    cmap: str
    dpi: int
    figsize: tuple[float, float]
    image_format: str

    @classmethod
    def from_config(cls, config: dict) -> "SpectrogramSettings":
        settings = config.get("spectrograms", {})
        figsize = settings.get("figsize", (6, 3))
        if isinstance(figsize, Iterable) and not isinstance(figsize, (str, bytes)):
            try:
                width, height = float(figsize[0]), float(figsize[1])
                figsize_tuple = (width, height)
            except (TypeError, ValueError, IndexError):
                figsize_tuple = (6.0, 3.0)
        else:
            figsize_tuple = (6.0, 3.0)

        return cls(
            sample_rate=settings.get("sample_rate"),
            n_fft=int(settings.get("n_fft", 2048)),
            hop_length=int(settings.get("hop_length", 512)),
            n_mels=int(settings.get("n_mels", 128)),
            fmin=float(settings.get("fmin", 0.0)),
            fmax=settings.get("fmax"),
            top_db=float(settings.get("top_db", 80.0)),
            cmap=str(settings.get("cmap", "magma")),
            dpi=int(settings.get("dpi", 150)),
            figsize=figsize_tuple,
            image_format=str(settings.get("image_format", "png")).lower(),
        )


class SpectrogramGenerator:
    """Generate mel spectrogram images for all clips of a species."""

    def __init__(
        self,
        config: dict,
        clips_dir: Optional[Path] = None,
        output_dir: Optional[Path] = None,
        overwrite: bool = False,
    ):
        self.config = config
        self.slug = config["species"]["slug"]

        root = Path(config["paths"]["root"]).expanduser()
        self.clips_dir = Path(clips_dir) if clips_dir else root / "clips" / self.slug
        self.output_dir = Path(output_dir) if output_dir else root / "spectrograms" / self.slug
        self.output_dir.mkdir(parents=True, exist_ok=True)

        self.settings = SpectrogramSettings.from_config(config)
        self.overwrite = overwrite

    def list_clips(self) -> list[Path]:
        """Return all audio clips for the species."""
        if not self.clips_dir.exists():
            raise FileNotFoundError(f"Clips directory not found: {self.clips_dir}")

        clips: list[Path] = [
            path
            for ext in CLIP_EXTENSIONS
            for path in sorted(self.clips_dir.glob(f"*{ext}"))
            if path.is_file()
        ]
        if not clips:
            raise FileNotFoundError(f"No audio clips found in {self.clips_dir}")
        return clips

    def generate_for_file(self, clip_path: Path) -> Optional[Path]:
        """Generate and save a spectrogram for a single clip."""
        output_path = self.output_dir / (clip_path.stem + f".{self.settings.image_format}")
        if output_path.exists() and not self.overwrite:
            return None

        y, sr = librosa.load(
            clip_path,
            sr=self.settings.sample_rate,
            mono=True,
        )

        spectrogram = librosa.feature.melspectrogram(
            y=y,
            sr=sr,
            n_fft=self.settings.n_fft,
            hop_length=self.settings.hop_length,
            n_mels=self.settings.n_mels,
            fmin=self.settings.fmin,
            fmax=self.settings.fmax,
        )
        spectrogram_db = librosa.power_to_db(spectrogram, ref=np.max, top_db=self.settings.top_db)

        fig, ax = plt.subplots(figsize=self.settings.figsize)
        librosa.display.specshow(
            spectrogram_db,
            sr=sr,
            hop_length=self.settings.hop_length,
            x_axis="time",
            y_axis="mel",
            cmap=self.settings.cmap,
            fmin=self.settings.fmin,
            fmax=self.settings.fmax,
        )
        ax.set_title(f"{self.slug} Â· {clip_path.stem}", fontsize=9)
        ax.set_xlabel("Time (s)")
        ax.set_ylabel("Mel frequency")

        fig.tight_layout()
        fig.savefig(
            output_path,
            dpi=self.settings.dpi,
            bbox_inches="tight",
            pad_inches=0.05,
        )
        plt.close(fig)

        return output_path

    def run(self, limit: Optional[int] = None) -> tuple[int, int]:
        """
        Generate spectrograms for all clips (or up to `limit`) and return counts.

        Returns:
            Tuple of (processed_clips, created_images).
        """
        clips = self.list_clips()
        if limit is not None:
            clips = clips[:limit]

        created = 0
        processed = 0

        for clip_path in tqdm(clips, desc=f"Generating spectrograms for {self.slug}"):
            processed += 1
            result = self.generate_for_file(clip_path)
            if result is not None:
                created += 1

        return processed, created


def parse_args() -> argparse.Namespace:
    """Parse command-line arguments."""
    parser = argparse.ArgumentParser(description="Generate spectrograms for a species' clips.")
    parser.add_argument("--config", type=Path, help="Path to config.yaml file.")
    parser.add_argument(
        "--clips-dir",
        type=Path,
        help="Override clips directory (defaults to <root>/clips/<slug>).",
    )
    parser.add_argument(
        "--output-dir",
        type=Path,
        help="Override spectrogram output directory (defaults to <root>/spectrograms/<slug>).",
    )
    parser.add_argument(
        "--overwrite",
        action="store_true",
        help="Regenerate spectrograms even if the image already exists.",
    )
    parser.add_argument(
        "--limit",
        type=int,
        help="Process at most N clips (useful for testing).",
    )
    return parser.parse_args()


def main() -> None:
    """Entrypoint for CLI."""
    args = parse_args()
    config = load_config(args.config)

    generator = SpectrogramGenerator(
        config=config,
        clips_dir=args.clips_dir,
        output_dir=args.output_dir,
        overwrite=bool(args.overwrite),
    )

    processed, created = generator.run(limit=args.limit)
    print(
        f"Processed {processed} clips for species '{generator.slug}'. "
        f"Created {created} spectrograms in {generator.output_dir}."
    )


if __name__ == "__main__":
    main()
